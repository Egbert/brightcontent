= Brightcontent

Yet another rails CMS / admin panel

* *For developers, to make a custom CMS for non-technical users*
* No standard 'cms-modules', we hate those, making custom is easy enough
* Build in the rails way, use your normals models, only controllers and views are provided
* Only exception: Page model is provided with tree structure, draft, hidden and pretty urls like <tt>/services/cleaning/houses</tt>

== Defaults in views
Brightcontent has some few default/overwrite functions.:

=== Default views
Finds views in the default folder if it cannot be found in the normal folder. 
For example, if <tt>/app/views/vacancy/new.html.erb</tt> doesn't exist, it will look at <tt>/app/views/default/new.html.erb</tt>

DefaultViews is a mixin included in <tt>Admin::ApplicationController</tt>

=== Default partials
Like DefaultViews, find partials in default folder if it cannot be found in the normals folder.

Implemented by <tt>find_partial</tt> function in <tt>Admin::ApplicationHelper</tt>

=== Default list and form fields
The list (index) and forms (new/edit) tries to find partials with the field names. If it cannot be found, it uses generic fields (textfield for string etc.).

For example the field <tt>title</tt> will be rendered in the list by  <tt>_list_field_title.html.erb</tt> if it exists. If not, it will be rendered with a normal label and textbox (because its a string).

<tt>index.html.erb</tt> and <tt>_form.html.erb</tt> uses <tt>list_field</tt> and <tt>form_field</tt> functions in <tt>Admin::ApplicationHelper</tt> 

== Default actions
Default crud actions are included. Generic variables <tt>@items</tt> (index) and <tt>@item</tt>(new, edit) are provided, but also with the specific name like <tt>@vacancies</tt> or <tt>@vacancy</tt>. Controllername should match modelname. You can overwrite the actions in the controller.

== Requirements
* Rails 3
* Uses ActiveRecord to find the type of column/field to render (in generic field)

= Setup

Install the plugin in the vendor/plugin directory

  rails plugin install git://github.com/brightin/brightcontent.git
  
Add the requirements to your <tt>Gemfile</tt>

  gem 'acts_as_tree'
  gem 'acts_as_list'
  gem 'will_paginate', :git => 'http://github.com/mislav/will_paginate.git', :branch => 'rails3'
  gem 'RedCloth'
  gem 'paperclip'

Run bundle install

  bundle install
  
Add admin routes for pages and other resources in <tt>config/routes.rb</tt>

  #admin routing
  get 'admin' => redirect('/admin/pages')
  namespace :admin do
    resources :pages do
      get :position_tag, :on => :member      #for edit
      get :position_tag, :on => :collection  #for new
    end
    #resources :vacancies  #for example
    resources :assets
    resources :users
    resource  :session, :only => [:new, :create, :destroy]
  end

Run sync to add migrations and public assets (CSS etc) en run migrations

  rake brightcontent:sync
  rake db:migrate
  
Add a user to login

  rails runner 'User.create({:email_address => "developers@brightin.nl", :password => "blabla"})'

Run forest run!

  rails s
  
and surf to http://0.0.0.0:3000/admin

== Add a new model to brightcontent

Lets say, we want to projects. Just create the Project model the rails way:
* Make migrations for project
* Rake db:migrate
* Add model file: <tt>app/models/project.rb</tt>

Then, for brightcontent:
Add <tt>resources :projects</tt> in <tt>config/routes.rb</tt> under the admin namespace.

Add new controller in <tt>app/controllers/admin/projects_controller.rb</tt>, inherit from <tt>Admin::ApplicationController</tt> and specify the fields you want to show in the index (list) and edit (form). For example:

  class Admin::ProjectController < Admin::ApplicationController
    before_filter :set_fields
    
    private
    def set_fields
      @list_fields = ['id', 'name']
      @form_fields = Project.column_names - ['created_at', 'updated_at', 'description']
    end
  end

== Public site
Add routing for your public site 

  # public routing
  # resources :vacancies, :path => "over/vacatures", :only => [:index, :show]   #for example
  root :to => "pages#show", :path => ''
  constraints PageUrls.new do
    get "*path" => "pages#show"
  end


Copyright (c) 2010 Raymond Vellener / Brightin, released under the MIT license
